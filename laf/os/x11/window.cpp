// LAF OS Library
// Copyright (C) 2018-2021  Igara Studio S.A.
// Copyright (C) 2017-2018  David Capello
//
// This file is released under the terms of the MIT license.
// Read LICENSE.txt for more information.

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "os/x11/window.h"

#include "base/clamp.h"
#include "base/debug.h"
#include "base/string.h"
#include "gfx/rect.h"
#include "gfx/region.h"
#include "os/event.h"
#include "os/surface.h"
#include "os/system.h"
#include "os/x11/keys.h"
#include "os/x11/x11.h"

#include <X11/cursorfont.h>
#include <map>

#define KEY_TRACE(...)
#define EVENT_TRACE(...)

#define LAF_X11_DOUBLE_CLICK_TIMEOUT 250

// TODO the window name should be customized from the CMakeLists.txt
//      properties (see OS_WND_CLASS_NAME too)
#define LAF_X11_WM_CLASS "Aseprite"

namespace os {

namespace {

// Event generated by the window manager when the close button on the
// window is pressed by the userh.
Atom wmDeleteMessage = 0;

// Cursor Without pixels to simulate a hidden X11 cursor
Cursor empty_xcursor = None;

// See https://bugs.freedesktop.org/show_bug.cgi?id=12871 for more
// information, it looks like the official way to convert a X Window
// into our own user data pointer (X11Window instance) is using a map.
std::map<::Window, X11Window*> g_activeWindows;

// Last time an XInput event was received, it's used to avoid
// processing mouse motion events that are generated at the same time
// for the XInput devices.
Time g_lastXInputEventTime = 0;

bool is_mouse_wheel_button(int button)
{
  return (button == Button4 || button == Button5 ||
          button == 6 || button == 7);
}

gfx::Point get_mouse_wheel_delta(int button)
{
  gfx::Point delta(0, 0);
  switch (button) {
    // Vertical wheel
    case Button4: delta.y = -1; break;
    case Button5: delta.y = +1; break;
    // Horizontal wheel
    case 6: delta.x = -1; break;
    case 7: delta.x = +1; break;
  }
  return delta;
}

} // anonymous namespace

// static
X11Window* X11Window::getPointerFromHandle(Window handle)
{
  auto it = g_activeWindows.find(handle);
  if (it != g_activeWindows.end())
    return it->second;
  else
    return nullptr;
}

// static
void X11Window::addWindow(X11Window* window)
{
  ASSERT(g_activeWindows.find(window->handle()) == g_activeWindows.end());
  g_activeWindows[window->handle()] = window;
}

// static
void X11Window::removeWindow(X11Window* window)
{
  auto it = g_activeWindows.find(window->handle());
  ASSERT(it != g_activeWindows.end());
  if (it != g_activeWindows.end()) {
    ASSERT(it->second == window);
    g_activeWindows.erase(it);
  }
}

X11Window::X11Window(::Display* display, int width, int height, int scale)
  : m_display(display)
  , m_gc(nullptr)
  , m_cursor(None)
  , m_xcursorImage(nullptr)
  , m_xic(nullptr)
  , m_scale(scale)
  , m_lastMousePos(-1, -1)
  , m_lastClientSize(0, 0)
  , m_doubleClickButton(Event::NoneButton)
{
  // Initialize special messages (just the first time a X11Window is
  // created)
  if (!wmDeleteMessage)
    wmDeleteMessage = XInternAtom(m_display, "WM_DELETE_WINDOW", False);

  ::Window root = XDefaultRootWindow(m_display);

  XSetWindowAttributes swa;
  swa.event_mask = (StructureNotifyMask | ExposureMask | PropertyChangeMask |
                    EnterWindowMask | LeaveWindowMask | FocusChangeMask |
                    ButtonPressMask | ButtonReleaseMask | PointerMotionMask |
                    KeyPressMask | KeyReleaseMask);

  m_window = XCreateWindow(
    m_display, root,
    0, 0, width, height, 0,
    CopyFromParent,
    InputOutput,
    CopyFromParent,
    CWEventMask,
    &swa);

  if (!m_window)
    throw std::runtime_error("Cannot create X11 window");

  setWMClass(LAF_X11_WM_CLASS);

  // Receive stylus/eraser events
  X11::instance()->xinput().selectExtensionEvents(m_display, m_window);

  XMapWindow(m_display, m_window);
  XSetWMProtocols(m_display, m_window, &wmDeleteMessage, 1);

  m_gc = XCreateGC(m_display, m_window, 0, nullptr);

  XIM xim = X11::instance()->xim();
  if (xim) {
    m_xic = XCreateIC(xim,
                      XNInputStyle, XIMPreeditNothing | XIMStatusNothing,
                      XNClientWindow, m_window,
                      XNFocusWindow, m_window,
                      nullptr);
  }
  X11Window::addWindow(this);
}

X11Window::~X11Window()
{
  if (m_xcursorImage != None)
    XcursorImageDestroy(m_xcursorImage);
  if (m_xic)
    XDestroyIC(m_xic);
  XFreeGC(m_display, m_gc);
  XDestroyWindow(m_display, m_window);

  X11Window::removeWindow(this);
}

void X11Window::queueEvent(Event& ev)
{
  onQueueEvent(ev);
}

os::ColorSpacePtr X11Window::colorSpace() const
{
  // TODO get the window color space
  return os::instance()->createColorSpace(gfx::ColorSpace::MakeSRGB());
}

void X11Window::setScale(const int scale)
{
  m_scale = scale;
  onResize(clientSize());
}

void X11Window::setTitle(const std::string& title)
{
  XTextProperty prop;
  prop.value = (unsigned char*)title.c_str();
  prop.encoding = XA_STRING;
  prop.format = 8;
  prop.nitems = std::strlen((char*)title.c_str());
  XSetWMName(m_display, m_window, &prop);
}

void X11Window::setIcons(const SurfaceList& icons)
{
  if (!m_display || !m_window)
    return;

  bool first = true;
  for (Surface* icon : icons) {
    const int w = icon->width();
    const int h = icon->height();

    SurfaceFormatData format;
    icon->getFormat(&format);

    std::vector<unsigned long> data(w*h+2);
    int i = 0;
    data[i++] = w;
    data[i++] = h;
    for (int y=0; y<h; ++y) {
      const uint32_t* p = (const uint32_t*)icon->getData(0, y);
      for (int x=0; x<w; ++x, ++p) {
        uint32_t c = *p;
        data[i++] =
          (((c & format.blueMask ) >> format.blueShift )      ) |
          (((c & format.greenMask) >> format.greenShift) <<  8) |
          (((c & format.redMask  ) >> format.redShift  ) << 16) |
          (((c & format.alphaMask) >> format.alphaShift) << 24);
      }
    }

    Atom _NET_WM_ICON = XInternAtom(m_display, "_NET_WM_ICON", False);
    XChangeProperty(
      m_display, m_window, _NET_WM_ICON, XA_CARDINAL, 32,
      first ? PropModeReplace:
              PropModeAppend,
      (const unsigned char*)&data[0], data.size());

    first = false;
  }
}

gfx::Size X11Window::clientSize() const
{
  Window root;
  int x, y;
  unsigned int width, height, border, depth;
  XGetGeometry(m_display, m_window, &root,
               &x, &y, &width, &height, &border, &depth);
  return gfx::Size(int(width), int(height));
}

gfx::Size X11Window::restoredSize() const
{
  Window root;
  int x, y;
  unsigned int width, height, border, depth;
  XGetGeometry(m_display, m_window, &root,
               &x, &y, &width, &height, &border, &depth);
  return gfx::Size(int(width), int(height));
}

void X11Window::captureMouse()
{
  XGrabPointer(m_display, m_window, False,
               PointerMotionMask | ButtonPressMask | ButtonReleaseMask,
               GrabModeAsync, GrabModeAsync,
               None, None, CurrentTime);
}

void X11Window::releaseMouse()
{
  XUngrabPointer(m_display, CurrentTime);
}

void X11Window::setMousePosition(const gfx::Point& position)
{
  Window root;
  int x, y;
  unsigned int w, h, border, depth;
  XGetGeometry(m_display, m_window, &root,
               &x, &y, &w, &h, &border, &depth);
  XWarpPointer(m_display, m_window, m_window, 0, 0, w, h,
               position.x*m_scale, position.y*m_scale);
}

void X11Window::invalidateRegion(const gfx::Region& rgn)
{
  gfx::Rect bounds = rgn.bounds();
  onPaint(gfx::Rect(bounds.x*m_scale,
                    bounds.y*m_scale,
                    bounds.w*m_scale,
                    bounds.h*m_scale));
}

bool X11Window::setNativeMouseCursor(NativeCursor cursor)
{
  Cursor xcursor = None;

  switch (cursor) {
    case kNoCursor: {
      if (empty_xcursor == None) {
        char data = 0;
        Pixmap image = XCreateBitmapFromData(
          m_display, m_window, (char*)&data, 1, 1);

        XColor color;
        empty_xcursor = XCreatePixmapCursor(
          m_display, image, image, &color, &color, 0, 0);

        XFreePixmap(m_display, image);
      }
      xcursor = empty_xcursor;
      break;
    }
    case kArrowCursor:
      xcursor = XCreateFontCursor(m_display, XC_arrow);
      break;
    case kCrosshairCursor:
      xcursor = XCreateFontCursor(m_display, XC_crosshair);
      break;
    case kIBeamCursor:
      xcursor = XCreateFontCursor(m_display, XC_xterm);
      break;
    case kWaitCursor:
      xcursor = XCreateFontCursor(m_display, XC_watch);
      break;
    case kLinkCursor:
      xcursor = XCreateFontCursor(m_display, XC_hand1);
      break;
    case kHelpCursor:
      xcursor = XCreateFontCursor(m_display, XC_question_arrow);
      break;
    case kForbiddenCursor:
      xcursor = XCreateFontCursor(m_display, XC_X_cursor);
      break;
    case kMoveCursor:
      xcursor = XCreateFontCursor(m_display, XC_fleur);
      break;
    case kSizeNCursor:
      xcursor = XCreateFontCursor(m_display, XC_top_side);
      break;
    case kSizeNSCursor:
      xcursor = XCreateFontCursor(m_display, XC_sb_v_double_arrow);
      break;
    case kSizeSCursor:
      xcursor = XCreateFontCursor(m_display, XC_bottom_side);
      break;
    case kSizeWCursor:
      xcursor = XCreateFontCursor(m_display, XC_left_side);
      break;
    case kSizeECursor:
      xcursor = XCreateFontCursor(m_display, XC_right_side);
      break;
    case kSizeWECursor:
      xcursor = XCreateFontCursor(m_display, XC_sb_h_double_arrow);
      break;
    case kSizeNWCursor:
      xcursor = XCreateFontCursor(m_display, XC_top_left_corner);
      break;
    case kSizeNECursor:
      xcursor = XCreateFontCursor(m_display, XC_top_right_corner);
      break;
    case kSizeSWCursor:
      xcursor = XCreateFontCursor(m_display, XC_bottom_left_corner);
      break;
    case kSizeSECursor:
      xcursor = XCreateFontCursor(m_display, XC_bottom_right_corner);
      break;
  }

  return setX11Cursor(xcursor);
}

bool X11Window::setNativeMouseCursor(const os::Surface* surface,
                                     const gfx::Point& focus,
                                     const int scale)
{
  ASSERT(surface);

  // This X11 server doesn't support ARGB cursors.
  if (!XcursorSupportsARGB(m_display))
    return false;

  SurfaceFormatData format;
  surface->getFormat(&format);

  // Only for 32bpp surfaces
  if (format.bitsPerPixel != 32)
    return false;

  const int w = scale*surface->width();
  const int h = scale*surface->height();

  Cursor xcursor = None;
  if (m_xcursorImage == None ||
      m_xcursorImage->width != XcursorDim(w) ||
      m_xcursorImage->height != XcursorDim(h)) {
    if (m_xcursorImage != None)
      XcursorImageDestroy(m_xcursorImage);
    m_xcursorImage = XcursorImageCreate(w, h);
  }
  if (m_xcursorImage != None) {
    XcursorPixel* dst = m_xcursorImage->pixels;
    for (int y=0; y<h; ++y) {
      const uint32_t* src = (const uint32_t*)surface->getData(0, y/scale);
      for (int x=0, u=0; x<w; ++x, ++dst) {
        uint32_t c = *src;
        *dst =
          (((c & format.alphaMask) >> format.alphaShift) << 24) |
          (((c & format.redMask  ) >> format.redShift  ) << 16) |
          (((c & format.greenMask) >> format.greenShift) << 8) |
          (((c & format.blueMask ) >> format.blueShift ));
        if (++u == scale) {
          u = 0;
          ++src;
        }
      }
    }

    // We have to limit the focus position inside the cursor area to
    // avoid crash from XcursorImageLoadCursor():
    //
    //   X Error of failed request:  BadMatch (invalid parameter attributes)
    //     Major opcode of failed request:  138 (RENDER)
    //     Minor opcode of failed request:  27 (RenderCreateCursor)
    m_xcursorImage->xhot = base::clamp(scale*focus.x + scale/2, 0, w-1);
    m_xcursorImage->yhot = base::clamp(scale*focus.y + scale/2, 0, h-1);
    xcursor = XcursorImageLoadCursor(m_display,
                                     m_xcursorImage);
  }

  return setX11Cursor(xcursor);
}

void X11Window::setWMClass(const std::string& res_class)
{
  std::string res_name = base::string_to_lower(res_class);
  XClassHint ch;
  ch.res_name = (char*)res_name.c_str();
  ch.res_class = (char*)res_class.c_str();
  XSetClassHint(m_display, m_window, &ch);
}

bool X11Window::setX11Cursor(::Cursor xcursor)
{
  if (m_cursor != None) {
    if (m_cursor != empty_xcursor) // Don't delete empty_xcursor
      XFreeCursor(m_display, m_cursor);
    m_cursor = None;
  }
  if (xcursor != None) {
    m_cursor = xcursor;
    XDefineCursor(m_display, m_window, xcursor);
    return true;
  }
  else
    return false;
}

void X11Window::processX11Event(XEvent& event)
{
  auto xinput = &X11::instance()->xinput();
  if (xinput->handleExtensionEvent(event)) {
    Event ev;
    xinput->convertExtensionEvent(event, ev, m_scale,
                                  g_lastXInputEventTime);
    queueEvent(ev);
    return;
  }

  switch (event.type) {

    case ConfigureNotify: {
      gfx::Size newSize(event.xconfigure.width,
                        event.xconfigure.height);

      if (newSize.w > 0 &&
          newSize.h > 0 &&
          newSize != m_lastClientSize) {
        m_lastClientSize = newSize;
        onResize(newSize);
      }
      break;
    }

    case Expose: {
      gfx::Rect rc(event.xexpose.x, event.xexpose.y,
                   event.xexpose.width, event.xexpose.height);
      onPaint(rc);
      break;
    }

    case KeyPress:
    case KeyRelease: {
      Event ev;
      ev.setType(event.type == KeyPress ? Event::KeyDown: Event::KeyUp);

      KeySym keysym = XLookupKeysym(&event.xkey, 0);
      ev.setScancode(x11_keysym_to_scancode(keysym));

      if (m_xic) {
        std::vector<char> buf(16);
        size_t len = Xutf8LookupString(m_xic, &event.xkey,
                                       &buf[0], buf.size(),
                                       nullptr, nullptr);
        if (len < buf.size())
          buf[len] = 0;
        std::wstring wideChars = base::from_utf8(std::string(&buf[0]));
        if (!wideChars.empty())
          ev.setUnicodeChar(wideChars[0]);
        KEY_TRACE("Xutf8LookupString %s\n", &buf[0]);
      }

      // Key event used by the input method (e.g. when the user
      // presses a dead key).
      if (XFilterEvent(&event, m_window))
        break;

      int modifiers = (int)get_modifiers_from_x(event.xkey.state);
      switch (keysym) {
        case XK_space: {
          switch (event.type) {
            case KeyPress:
              g_spaceBarIsPressed = true;
              break;
            case KeyRelease:
              g_spaceBarIsPressed = false;

              // If the next event after a KeyRelease is a KeyPress of
              // the same keycode (the space bar in this case), it
              // means that this KeyRelease is just a repetition of a
              // the same keycode.
              if (XEventsQueued(m_display, QueuedAfterReading)) {
                XEvent nextEvent;
                XPeekEvent(m_display, &nextEvent);
                if (nextEvent.type == KeyPress &&
                    nextEvent.xkey.time == event.xkey.time &&
                    nextEvent.xkey.keycode == event.xkey.keycode) {
                  g_spaceBarIsPressed = true;
                }
              }
              break;
          }
          break;
        }
        case XK_Shift_L:
        case XK_Shift_R:
          modifiers |= kKeyShiftModifier;
          break;
        case XK_Control_L:
        case XK_Control_R:
          modifiers |= kKeyCtrlModifier;
          break;
        case XK_Alt_L:
        case XK_Alt_R:
          modifiers |= kKeyAltModifier;
          break;
        case XK_Meta_L:
        case XK_Super_L:
        case XK_Meta_R:
        case XK_Super_R:
          modifiers |= kKeyWinModifier;
          break;
      }
      ev.setModifiers((KeyModifiers)modifiers);
      KEY_TRACE("%s state=%04x keycode=%04x\n",
                (event.type == KeyPress ? "KeyPress": "KeyRelease"),
                event.xkey.state,
                event.xkey.keycode);
      KEY_TRACE(" > %s\n", XKeysymToString(keysym));

      queueEvent(ev);
      break;
    }

    case ButtonPress:
    case ButtonRelease: {
      // This can happen when the button press/release events are
      // handled in XInput
      if (event.xmotion.time == g_lastXInputEventTime)
        break;

      Event ev;
      if (is_mouse_wheel_button(event.xbutton.button)) {
        if (event.type == ButtonPress) {
          ev.setType(Event::MouseWheel);
          ev.setWheelDelta(get_mouse_wheel_delta(event.xbutton.button));
        }
        else {
          // Ignore ButtonRelese for the mouse wheel to avoid
          // duplicating MouseWheel event effects.
          break;
        }
      }
      else {
        ev.setType(event.type == ButtonPress? Event::MouseDown:
                                              Event::MouseUp);

        Event::MouseButton button =
          get_mouse_button_from_x(event.xbutton.button);
        ev.setButton(button);

        if (event.type == ButtonPress) {
          if (m_doubleClickButton == button &&
              base::current_tick() - m_doubleClickTick < LAF_X11_DOUBLE_CLICK_TIMEOUT) {
            ev.setType(Event::MouseDoubleClick);
            m_doubleClickButton = Event::NoneButton;
          }
          else {
            m_doubleClickButton = button;
            m_doubleClickTick = base::current_tick();
          }
        }
      }
      ev.setModifiers(get_modifiers_from_x(event.xbutton.state));
      ev.setPosition(gfx::Point(event.xbutton.x / m_scale,
                                event.xbutton.y / m_scale));

      queueEvent(ev);
      break;
    }

    case MotionNotify: {
      // This can happen when the motion event are handled in XInput
      if (event.xmotion.time == g_lastXInputEventTime)
        break;

      // Reset double-click state
      m_doubleClickButton = Event::NoneButton;

      gfx::Point pos(event.xmotion.x / m_scale,
                     event.xmotion.y / m_scale);

      if (m_lastMousePos == pos)
        break;
      m_lastMousePos = pos;

      Event ev;
      ev.setType(Event::MouseMove);
      ev.setModifiers(get_modifiers_from_x(event.xmotion.state));
      ev.setPosition(pos);
      queueEvent(ev);
      break;
    }

    case EnterNotify:
    case LeaveNotify:
      g_spaceBarIsPressed = false;

      // "mode" can be NotifyGrab or NotifyUngrab when middle mouse
      // button is pressed/released. We must not generated
      // MouseEnter/Leave events on those cases, only on NotifyNormal
      // (when mouse leaves/enter the X11 window).
      if (event.xcrossing.mode == NotifyNormal) {
        Event ev;
        ev.setType(event.type == EnterNotify ? Event::MouseEnter:
                                               Event::MouseLeave);
        ev.setModifiers(get_modifiers_from_x(event.xcrossing.state));
        ev.setPosition(gfx::Point(event.xcrossing.x / m_scale,
                                  event.xcrossing.y / m_scale));
        queueEvent(ev);
      }
      break;

    case ClientMessage:
      // When the close button is pressed
      if (Atom(event.xclient.data.l[0]) == wmDeleteMessage) {
        Event ev;
        ev.setType(Event::CloseDisplay);
        queueEvent(ev);
      }
      break;

  }
}

} // namespace os
